JAVA基础 

01 面向对象的基本特征有哪些？分别解释；
・面向对象的四大特征为：封装、继承、多态、抽象；
・封装是将业务相近的、可重用的属性和方法封装为类，进而通过类的对象实例去调用；
・继承的目的是对现有类进行扩展和修改，扩展就是增加新的属性与方法，修改是指通过覆写父类方法实现自身的差异化实现；
・多态是指同一父类或接口可以有多个不同的子类或实现类，外界在调用时可以不必关心子类的具体实现，而只需要统一调用父类方法来实现业务逻辑；
・抽象是指父类或接口定义一个方法，但是不去做具体实现，而是将其定义为抽象方法，留待子类去做具体实现；
・抽象是多态的基础；



02 何为同步？何为异步？何为异步回调？
・同步/异步指的是任务间的时间先后关系；
・假设有A、B两个彼此独立的任务：
	如果B任务要在A任务结束后才能触发，就称这两个任务是同步的；
	如果A、B彼此互不干扰，并发执行，就称它们之间是异步的（步调不一致，各走各的）――显然异步是要借助于线程的；
・异步回调是指：工作线程事先持有一个接口实例（通过传参、setter、构造方法均可），并在任务完成后去回调这个实例中的方法，即为异步+回调；
・异步回调的场景举例：
	主线程开启一条工作线程下载文件，并给这条线程设置一个回调接口（其实现为弹窗提示下载完成），之后主线程继续执行；
	下载线程在下载完毕后回调当初设置好的接口方法；
	主线程弹窗提示下载完成；



03 数组与List、Map、Set这几种集合类型有何异同？
・数组可以存取基本或对象类型的数据；数组是集合的底层实现，因此效率优于集合；但其长度是固定的，且数据类型必须是单一的，因此易用性不足；
・集合只能存取对象型数据；
・List，列表，有序（可按位置进行存取），对象内容可以重复；
・Set，集合，无序，对象内容不重复；
・Map，映射，以键值对的方式存取数据；



04 比较HashMap和HashTable的异同；
・HashMap的存取是异步的，HashTable的存取是同步的，――因此HashMap效率较高，但HashTable是线程安全的；
・HashMap允许有空键值，而HashTable不允许；
・HashMap查询是否存在键值的API为：containsValue()和containsKey()，HashTable为contains()；



05 何为线程安全？
・【线程安全】就是指一个对象不能被多个线程并发修改；
・一个对象如果能够被多个线程并发修改，它就不是线程安全的；



06 你熟悉SQL语句么？如何实现从【全年级学生成绩表】中查出各班的男同学的平均分、忽略平均分不及格的班级、按降序排列、并取其中的前三名？
・当然至少是比较熟悉的；
select 
avg(score) s,class
from students
where male = 1
group by class
having s > 60
order by s desc
limit 3
・group by、limit、常用的数据库函数都是常用的比较重要的SQL语法；



07 说说Socket通信的原理和一般步骤；
・又称套接字；
・基于TCP/IP协议；//（所以访问地址是IP+端口）
・基于长连接；//（Http基于短连接，返回数据后立即断开连接）
・客户端通过指定IP与端口，建立与服务端的连接；
・ServerSocket阻塞监听连接请求，并为每一个成功连接的客户端Socket建立一条独立的线程；
・连接建立后，服客两端通过输入输出流相互发送数据；
・通信结束后，断开Socket连接(disconnect)；



08 你熟悉哪些常用的设计模式？
・单例（控制对象的数量）：
・工厂（统一管理对象的创建，防止无度的new对象实例）：BitmapFactory
・适配器（将数据映射为对象）：BaseAdapter
・观察者（数据变化时通知机制）：OnClickListener
・构造器（一条龙的setter，代码简洁）：AlertDialogBuilder
・组合（同种类的实例相互嵌套持有）：ViewGroup

为什么要用设计模式
提高程序执行的效率
设计模式可以帮助我们改善系统的设计，增强系统的健壮性、可扩展性，为以后铺平道路。

反对过度使用设计模式



09 反射的原理是什么？
・运行时动态装配类的实例，并调用其属性和方法；
・首要步骤是获得class对象，可以通过类名或实例的getClass()方法两种手段获取；
・一旦得到class对象，就可以访问其中的所有属性和方法，包括私有属性和方法；
・反射机制在各种框架中被广泛使用；
・JNI中C调用JAVA也是通过反射机制实现的；



10 你了解注解的原理么？
・注解可以作用于类、属性或方法上；
・注解类中可以声明一系列相关方法，使用注解时以参数形式定义这些方法的返回值；
・运行时“解读类”能够通过调用注解类中声明的方法，获取其作用对象中注入的值，进而进行相应的业务处理；
・注解对象的“解读”工作，也是通过反射机制实现的；
・【注解 + 反射】在各种框架中被广泛使用；



11 为什么要使用泛型？
・泛型的作用是保证类型安全；
・任何想要声明类型（方法参数类型，方法返回值类型，属性类型）的地方，如果不确定类型，可以标记为泛型；
・创建泛型类对象（或继承泛型类）时，为保证类型安全，可以对泛型做具体类型声明；
・在使用实例或子类时，原泛型的位置必须使用具体声明的类型，否则就称之为类型不安全，将通不过编译；
・例如ArrayList<T>，当data = new ArrayList<String>()时，data中能且只能放String类型对象，否则会编译报错；